import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
from astropy.io import fits
#import pyfits
#from skimage import exposure
### Importing 'skimage' causes a crash?
import montage_wrapper as montage

import os

tile_list_orionis = \
[
"G189m06",
"G189m12",
"G190m09",
"G190m18",
"G191m15",
"G192m06",
"G192m12",
"G193m09",
"G193m18",
"G194m15",
"G195m06",
"G195m12",
"G196m09",
"G197m15",
"G197m18",
"G198m06",
"G198m12",
"G199m09",
"G200m15",
"G200m18",
"G201m06",
"G201m12",
"G202m09",
"G203m15",
"G203m18",
]

#for tile in tile_list_orionis:
#        os.system('rm '+data_dir+"orionis_mc_tmp/"+tile+"_S.noisy.fits")\
    
def pre_processing(data, offset=0):

    from astropy.stats import sigma_clip as sc

    ## Pre-processing 1: Convert zeros to NaNs 
    data[data==0] = np.nan
    ## Pre-processing 2: Offset subtraction
    data         -= offset
    ## Point-source masking
    data = sc(data,sigma=2, iters=3)
    
    data_nand = data.data
    
    data_nand[data.mask == True] = np.nan
    
    return data_nand

    
def perturb_the_tiles(tiles, offset=0, noise=True, band = 'S'):
    
    
    data_dir = "/work1/users/aaronb/Databrary/IRC/IRC_ASM_sample_beta4/S_data/"
    sigma_dir = "/work1/users/aaronb/Databrary/IRC/IRC_ASM_sample_beta4/"

    os.system('rm -r '+data_dir+"orionis_mc tmp/")
    os.system('mkdir '+data_dir+"orionis_mc_tmp/")
    

    
    if noise == True:
        "Adding the noise"
        for tile in tiles:
    
            img_data  = fits.open(data_dir+tile+"_"+band+".fits")
            img_sigma = fits.open(sigma_dir+tile+"_S.sigma.fits")
    
            #img_sigma[0].shape
            ### The 'EXTEND' card seems to be in the wrong position. 
            ### The FITS standard format documenatation says it should come after NAXIS/NAXIS2
            ### We'll move it...
            #img_data[0].header.remove('EXTEND')
            #img_data[0].header.insert('NAXIS2', ('EXTEND', 'F'),
            #          after=True)
            #img_data[0].header
    
            img_random = np.random.normal(loc=0.0, scale = 1.0, size = img_data[0].shape)
            
        
            img_data[0].data = img_data[0].data + img_sigma[0].data*img_random
        
            img_data[0].data = pre_processing(img_data[0].data, offset=offset)

            img_data[0].header['EXTEND'] = False
            #img_data[0].header
    
            img_data.writeto(data_dir+"orionis_mc_tmp/"+tile+"_S.noisy.fits",clobber=True)
        
            #print tile+" finished!"+"Dev. from original: "
        
            #make_the_mosaic(iteration)
            
        print "Tiles processed"
        
    else:
            
        print " Doing the pre-processing (without adding noise!!!)"
            
        for tile in tiles:
            
            img_data  = fits.open(data_dir+tile+"_S.fits")
            
            img_data[0].data = pre_processing(img_data[0].data, offset=offset)
            
            img_data[0].header['EXTEND'] = False
            
            img_data.writeto("/work1/users/aaronb/Databrary/IRC/IRC_ASM_sample_beta4/S_data/orionis_mc_tmp/"+tile+"_S.noisy.fits",clobber=True)
            
        print "Tiles processed"
            
        


def make_the_mosaic(iteration=0, noise=True):
    
    header          = "/work1/users/aaronb/Databrary/Orionis_test/mosaic_subset/transformed_direct/transformed.hdr"
    rawtiledir      = "/work1/users/aaronb/Databrary/IRC/IRC_ASM_sample_beta4/S_data/orionis_mc_tmp/"
    image_table     = "/work1/users/aaronb/Databrary/IRC/IRC_ASM_sample_beta4/S_data/mc_tmp_images.tbl"
    work_dir        = "/work1/users/aaronb/Databrary/montage_tmp"
    
    if noise==True:
        mosaic          = "/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_"+str(iteration)
    else:    
        mosaic          = "/work1/users/aaronb/Databrary/Orionis_test/MC_test/out_unperturbed"

        
    os.system('rmdir ' + mosaic)
    os.system('rm -r ' + mosaic)
    
    #os.system('mkdir '+ mosaic)
    

    montage.mosaic(rawtiledir, 
               mosaic,
               header=header,
               image_table=image_table,
               cleanup=True)

    #fits_display_test(mosaic+"mosaic.fits")
    
    ## Clean out the temporary files generated by the initial test run


def do_the_mc(tile_list, iterations = 10, degrade = True, smooth = True, offset = 2.0, noise=True, band='S'):
    
    def smoothing(final_out_dir):
        
        print "Doing the smoothing"
        
        ## Import convolution modules
        from astropy.convolution import convolve, convolve_fft, Gaussian2DKernel

        ## Load the huge mosaic into memory
        from astropy.io.fits import getdata
        from astropy.io.fits import getheader

        ## Import the Colonel
        FWHM = 4.4 #arcmin
        kernel = Gaussian2DKernel(stddev=FWHM)
    
        smooth_out_name = final_out_dir + "smoothed_"+band+".fits"

        #os.system('rm -r '+final_out_dir)

        image = fits.open(final_out_dir+"mosaic.fits")

        image[0].data = convolve_fft(image[0].data, kernel, boundary='periodic')

        image.writeto(smooth_out_name)
        print "Smoothed image written"

        #fits_display_test(final_out_name)
        
        
            
    def degrading(final_out_dir):
        
        print "Doing the degrading"
        
        regrid_out_name = final_out_dir + "regridded_"+band+".fits"
        
        smooth_out_name = final_out_dir + "smoothed_"+band+".fits"
        
        trimmed_out_name = final_out_dir + "trimmed_"+band+".fits"

        montage.commands.mSubimage(smooth_out_name, trimmed_out_name, 84.25, 9.11, 10.0)
        print "Trimmed image written"
        # the next step rebings the image to ~0.5deg/pixel
        montage.commands.mShrink(trimmed_out_name, regrid_out_name, factor=10, fixed_size=True) 
        # now that the image is at the desired scale and PSF, we trim off the edges:
        "Regridded image written"
    
    if noise == True:
        
        print "Hammer time."
        
        # Intialize the counter:
        iteration = 0
        
        final_out_dir  ="/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_"+str(iteration)+"/"
        
        mc_frames = []
        
        for iteration in range(0,iterations):
        
            print "Gettin' started on iteration #"+str(iteration)
    
            perturb_the_tiles(tile_list_orionis, offset = offset, noise=noise, band = band)
        
            make_the_mosaic(iteration, noise=noise)

            #os.system("rm /work1/users/aaronb/Databrary/IRC/IRC_ASM_sample_beta4/S_data/orionis_mc_tmp/*")
            
            if smoothing == True:
                smoothing(final_out_dir)
            
            if degrading ==True:
                degrading(final_out_dir)

        
            mc_frame = fits.getdata("/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_"+str(iteration)+"/mosaic.fits")
            mc_frames.append(mc_frame)
        
        ## Put the frames into a numpy array:
        print "Making the the MC data cube array"
        mc_frames = np.array(mc_frames)
        
        ## Print the shape of the array to confirm nothing crazy happened. Should be like (10,10,20)
        print mc_frames.shape
        #mc_sample_pixel= mc_frames[:,xpix,ypix]
        
        
        ## Take the standard deviation for each pixel, along the 3rd dimension (the iterations)
        ## Result should be a single 10 by 10 frame
        print "Taking the standard deviation of each pixel"
        mc_std   = np.nanstd(mc_frames, axis=2)
        print "mc_std.shape = "+mc_std.shape 
        
        print "Writing out the standard deviation image"
        mc_hdu   = fits.open("/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_0/mosaic.fits")
    
        mc_hdu[0].data = mc_std
    
        mc_hdu.writeto("/work1/users/aaronb/Databrary/Orionis_test/MC_test/out_unperturbed/mosaic_"+band+".sigma.fits")
    
            
    else:
        
        print "Making the unperturbed reference image!"
    
        final_out_dir  ="/work1/users/aaronb/Databrary/Orionis_test/MC_test/out_unperturbed/"
        
        perturb_the_tiles(tile_list_orionis, offset = offset, noise=noise)
        
        make_the_mosaic(noise=noise)

        #os.system("rm /work1/users/aaronb/Databrary/IRC/IRC_ASM_sample_beta4/S_data/orionis_mc_tmp/*")
        
        if smooth == True:
            smoothing(final_out_dir)
            
        if degrade ==True:
            degrading(final_out_dir)
    
    #fits_display_test("/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_"+str(frame)+"/mosaic.fits")
    

    return mc_frames, mc_std, mc_hdu        

    
def check_guassianity(iterations,frame,xpix,ypix):
    
    from scipy import stats
    
    fits_display_test("/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_"+str(frame)+"/mosaic.fits")
    
    mc_frames = []
    
    for iteration in range(0,iterations):
        
        mc_frame = fits.getdata("/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_"+str(iteration)+"/mosaic.fits")
        mc_frames.append(mc_frame)
    
    mc_frames = np.array(mc_frames)
    #mc_sample_pixel= mc_frames[:,xpix,ypix]
    
    mc_std   = np.nanstd(mc_frames, axis=2)
    
    mc_hdu   = fits.open("/work1/users/aaronb/Databrary/Orionis_test/MC_test/iteration_0/mosaic.fits")
    
    mc_hdu[0].data = mc_std
    
    mc_hdu.writeto("/work1/users/aaronb/Databrary/Orionis_test/mosaic_subset/out_unperturbed/mosaic.sigma.fits")
    

    

    plt.hist(mc_sample_pixel)
    
    print np.std(mc_sample_pixel)
    
    return mc_std
    #print np.nanmin(mc_frames)
    #print stats.mode(mc_frames, axis=None)


def fits_display_test(image_file):
    
    import aplpy
    import atpy
    
    # Create a new figure
    fig = aplpy.FITSFigure(image_file)

    # Show the colorscale
    fig.show_colorscale()

    # Add contours
    #fig.show_contour(image_file, cmap='jet', levels=np.linspace(0.0, 1.0, 10))

    # Make ticks white
    fig.ticks.set_color('white')

    # Make labels smaller
    fig.tick_labels.set_font(size='small')

    # Overlay a grid
    fig.add_grid()
    fig.grid.set_alpha(0.5)

    # Add a colorbar
    fig.add_colorbar()
    
    plt.show()
    plt.close()
    
    
    

    
